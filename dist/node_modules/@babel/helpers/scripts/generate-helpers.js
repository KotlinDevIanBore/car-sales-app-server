"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = generateHelpers;
var _fs = _interopRequireDefault(require("fs"));
var _path = require("path");
var _url = require("url");
var _terser = require("terser");
var _babelTopLevel = require("$repo-utils/babel-top-level");
var _$repoUtils = require("$repo-utils");
var _zlib = require("zlib");
var _buildHelperMetadata = require("./build-helper-metadata.js");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
/* eslint-disable import/no-extraneous-dependencies */

const HELPERS_FOLDER = new _url.URL("../src/helpers", import.meta.url);
const IGNORED_FILES = new Set(["package.json", "tsconfig.json"]);
async function generateHelpers() {
  let output = `/*
 * This file is auto-generated! Do not modify it directly.
 * To re-generate run 'yarn gulp generate-runtime-helpers'
 */

import template from "@babel/template";
import type * as t from "@babel/types";

interface Helper {
  minVersion: string;
  ast: () => t.Program;
  metadata: HelperMetadata;
}

export interface HelperMetadata {
  globals: string[];
  locals: { [name: string]: string[] };
  dependencies: { [name: string]: string[] };
  exportBindingAssignments: string[];
  exportName: string;
}

function helper(minVersion: string, source: string, metadata: HelperMetadata): Helper {
  return Object.freeze({
    minVersion,
    ast: () => template.program.ast(source, { preserveComments: true }),
    metadata,
  })
}

export { helpers as default };
const helpers: Record<string, Helper> = {
  __proto__: null,
`;
  let babel7extraOutput = "";
  for (const file of (await _fs.default.promises.readdir(HELPERS_FOLDER)).sort()) {
    if (IGNORED_FILES.has(file)) continue;
    if (file.startsWith(".")) continue; // ignore e.g. vim swap files

    const [helperName] = file.split(".");
    const isTs = file.endsWith(".ts");
    const filePath = (0, _path.join)((0, _url.fileURLToPath)(HELPERS_FOLDER), file);
    if (!file.endsWith(".js") && !isTs) {
      console.error("ignoring", filePath);
      continue;
    }
    let code = await _fs.default.promises.readFile(filePath, "utf8");
    const minVersionMatch = code.match(/^\s*\/\*\s*@minVersion\s+(?<minVersion>\S+)\s*\*\/\s*$/m);
    if (!minVersionMatch) {
      throw new Error(`@minVersion number missing in ${filePath}`);
    }
    const {
      minVersion
    } = minVersionMatch.groups;
    const onlyBabel7 = code.includes("@onlyBabel7");
    const mangleFns = code.includes("@mangleFns");
    const noMangleFns = [];
    code = _babelTopLevel.babel.transformSync(code, {
      configFile: false,
      babelrc: false,
      filename: filePath,
      presets: [[_babelTopLevel.presetTypescript, {
        onlyRemoveTypeImports: true,
        optimizeConstEnums: true
      }]],
      plugins: [
      /**
       * @type {import("@babel/core").PluginObj}
       */
      ({
        types: t
      }) => ({
        // These pre/post hooks are needed because the TS transform is,
        // when building in the old Babel e2e test, removing the
        // `export { OverloadYield as default }` in the OverloadYield helper.
        // TODO: Remove in Babel 8.
        pre(file) {
          if (!process.env.IS_BABEL_OLD_E2E) return;
          file.metadata.exportName = null;
          file.path.traverse({
            ExportSpecifier(path) {
              if (path.node.exported.name === "default") {
                file.metadata.exportName = path.node.local.name;
              }
            }
          });
        },
        post(file) {
          if (!process.env.IS_BABEL_OLD_E2E) return;
          if (!file.metadata.exportName) return;
          file.path.traverse({
            ExportNamedDeclaration(path) {
              if (!path.node.declaration && path.node.specifiers.length === 0) {
                path.node.specifiers.push(t.exportSpecifier(t.identifier(file.metadata.exportName), t.identifier("default")));
              }
            }
          });
        },
        visitor: {
          ImportDeclaration(path) {
            const source = path.node.source;
            source.value = source.value.replace(/\.ts$/, "").replace(/^\.\//, "");
          },
          FunctionDeclaration(path) {
            if (mangleFns && path.node.leadingComments?.find(c => c.value.includes("@no-mangle"))) {
              const name = path.node.id.name;
              if (name) noMangleFns.push(name);
            }
          }
        }
      })]
    }).code;
    code = (await (0, _terser.minify)(code, {
      ecma: 5,
      mangle: {
        keep_fnames: mangleFns ? new RegExp(noMangleFns.join("|")) : true
      },
      // The _typeof helper has a custom directive that we must keep
      compress: {
        directives: false,
        passes: 10,
        unsafe: true,
        unsafe_proto: true
      }
    })).code;
    let metadata;
    // eslint-disable-next-line prefer-const
    [code, metadata] = (0, _buildHelperMetadata.getHelperMetadata)(_babelTopLevel.babel, code, helperName);
    const helperStr = `\
  // size: ${code.length}, gzip size: ${(0, _zlib.gzipSync)(code).length}
  ${JSON.stringify(helperName)}: helper(
    ${JSON.stringify(minVersion)},
    ${JSON.stringify(code)},
    ${(0, _buildHelperMetadata.stringifyMetadata)(metadata)}
  ),
`;
    if (onlyBabel7) {
      if (!(0, _$repoUtils.IS_BABEL_8)()) babel7extraOutput += helperStr;
    } else {
      output += helperStr;
    }
  }
  output += "};";
  if (babel7extraOutput) {
    output += `

if (!process.env.BABEL_8_BREAKING) {
  Object.assign(helpers, {
    ${babel7extraOutput}
  });
}
`;
  }
  return output;
}